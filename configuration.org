#+title: Configuration
#+date: <2023-08-15 Tue>
#+author: Jackson Brough

* "Are these your configuration files, Larry?"

This has been my experience with Emacs: I would re-clone my ~.emacs.d~
and recommit myself to the true way. It would last about a month or
so, and then I would hit up against some great stumbling block that no
amount of blog post debugging would fix. At that point I would throw
up my hands, admit to myself that I wasn't a real man, and go back to
VSCode.

I came back after a full year of not using Emacs because I was going
to be spending the summer writing [[https://github.com/herbie-fp/herbie][a bunch of Racket code]] and felt like
a fraud doing so in VSCode. I think there were a couple factors that
kept me from relapsing when August came around: I learned some elisp,
read the Info tutorial in its entirety so I would know how to use it,
and forced myself to ~C-h~ before googling a problem; I accidently
joined the NixOS cult, wasting a perfectly good summer weekend in the
process (See ~hlissner~'s [[https://github.com/hlissner/dotfiles][dotfiles]] for how 2 flakes[fn:1], and check out
Ian Henry's [[https://ianthehenry.com/posts/how-to-learn-nix/introduction/][blog series]] if you'd like some genuine comedy with your
maddenning Nix journey - I thought his writing was seriously
hilarious); I also made my first pass through /How to Take Smart
Notes/ by Sönke Ahrens this summer, and am therefore obligated to try
becoming an org-roam cultist as well.

I tried the whole [[https://nixos.wiki/wiki/Import_From_Derivation][IFD]] thing, and back in the git history there is an
attempt at a tiny flake that had just enough to tangle this org file,
build the generated flake as a derivation, and evaluate that
derivation by importing it, but I can't yet bend spoons with my nix
fu, so I have settled on the "commit the build artifacts" approach,
which I'm actually decently happy with.

* Flake

#+begin_src nix :tangle flake.nix :noweb yes
{
  description = "Are these your configuration files, Larry?";

  nixConfig = {
    extra-substituters = [
      "https://cache.nixos.org/"
      "https://nix-community.cachix.org"
    ];

    extra-trusted-public-keys = [
      "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
      "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs="
    ];
  };

  inputs = {
    nixpkgs.url = "nixpkgs/nixos-unstable";

    home-manager.url = "github:nix-community/home-manager";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";

    nix-darwin.url = "github:LnL7/nix-darwin";
    nix-darwin.inputs.nixpkgs.follows = "nixpkgs";

    nixcasks.url = "github:jacekszymanski/nixcasks";
    nixcasks.inputs.nixpkgs.follows = "nixpkgs";

    emacs-overlay.url = "github:nix-community/emacs-overlay";
    emacs-overlay.inputs.nixpkgs.follows = "nixpkgs";

    agenix.url = "github:ryantm/agenix";
    agenix.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs = { self, nixpkgs, home-manager, nix-darwin, nixcasks, emacs-overlay, agenix }:
    rec {
      nixosModules = rec {
        <<modules>>
      };
      <<systems>>
      formatter = nixpkgs.lib.genAttrs [ "x86_64-darwin" "x86_64-linux" "aarch64-linux" ] (system: {
        system = nixpkgs.legacyPackages.${system}.nixpkgs-fmt;
      });
      <<templates>>
    };
}
#+end_src

* Modules
:PROPERTIES:
:header-args: :noweb-ref modules
:END:

** Personal information

#+begin_src nix
personal = { lib, ... }:

  {
    options.personal = lib.mkOption {
      type = lib.types.attrs;
      default = {
        userName = "jackson";
        fullName = "Jackson Brough";
        email = "jacksontbrough@gmail.com";
        devices = {
          kenobi = {
            ssh = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBndIK51b/o6aSjuTdoa8emnpCRg0s5y68oXAFR66D4/ jacksontbrough@gmail.com";
            syncthing = "7MDSHYK-QQSLKTX-LDA4VKP-EJASTEQ-V5JUGRT-ZRCNC7K-BFK6KQR-GAZ4JQV";
          };
          share1 = {
            ssh = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFpnGMEUElcwgnuHpBXQa4xotZrRdT6VC/7b9n5TykXZ root@share1";
            syncthing = "CQ6ZTVZ-PWRWMW2-2BTFJ7V-XSMIHHU-VS4JIPD-HI3ALDJ-FH6HW5L-Z3WDIAX";
            hostName = "share1.tail662f8.ts.net";
          };
          jackson-broughs-iphone = {
            syncthing = "64BJT3J-XFGZYTG-TMJXAS5-4XACLPE-JUF6XHS-5G4DFYW-2QVAC4T-LLRKUAL";
          };
        };
      };
    };
  };
#+end_src

** Default directories

#+begin_src nix
defaultDirectories = { config, lib, ... }:

  {
    options.defaultDirectories = {
      repositoriesDirectory = lib.mkOption { type = lib.types.str; default = "${config.home.homeDirectory}/repositories"; };
      localDirectory = lib.mkOption { type = lib.types.str; default = "${config.home.homeDirectory}/local"; };
      scratchDirectory = lib.mkOption { type = lib.types.str; default = "${config.home.homeDirectory}/scratch"; };
      shareDirectory = lib.mkOption { type = lib.types.str; default = "${config.home.homeDirectory}/share"; };
    };
  };
#+end_src

** Package manager configuration
Make Nix can flakes.

#+begin_src nix
package-manager = { pkgs, ... }:

  {
    nix.package = pkgs.nixFlakes;
    nix.settings.experimental-features = [ "nix-command" "flakes" ];

    nixpkgs.config.allowUnfree = true;
  };
#+end_src

** System

I include ~git~ (and ~curl~ and ~neovim~) on every system to prevent a
world of pain where I spend upwards of twenty minutes cursing the nix
2.4 binary before realizing that it wants git to exist in the universe
but refused to tell me that. Prolly should also include the busybox
tools on every system, but that had weird ~lspci~ output that left a
bad taste in my mouth. Also, I don't yet feel fully qualified: I
haven't had to set my init process to a statically linked python2 to
recover my machine.

#+begin_src nix
system = { config, pkgs, ... }:

  {
    imports = [ agenix.nixosModules.default package-manager personal ];

    nix.settings.trusted-users = [ "root" config.personal.userName ];

    environment.systemPackages = with pkgs; [ curl git neovim ];
    environment.shells = with pkgs; [ bashInteractive zsh fish ];

    programs.fish.enable = true;

    users.users.${config.personal.userName}.shell = pkgs.fish;
  };
#+end_src

** Darwin system

#+begin_src nix
darwinSystem = { config, pkgs, ... }:

  {
    imports = [ system ];

    config = {
      services.nix-daemon.enable = true;
      system.configurationRevision = self.rev or self.dirtyRev or null;
      system.stateVersion = 4;

      users.users.${config.personal.userName}.home = "/Users/${config.personal.userName}";

      homebrew.enable = true;
      homebrew.casks = [
        "discord"
        "docker"
        "slack"
        "spotify"
        "zoom"
      ];

      services.tailscale.enable = true;
    };
  };
#+end_src

** Home

#+begin_src nix
home = { lib, config, pkgs, ... }:

  {
    imports = [ personal defaultDirectories ];

    nixpkgs.overlays = [ agenix.overlays.default ];

    home.username = config.personal.userName;
    home.stateVersion = "23.05";
    home.packages = with pkgs; [
      direnv
      eza
      fd
      gopass
      ispell
      jq
      lldb
      pkgs.agenix
      ripgrep
    ];
    programs.home-manager.enable = true;
  
    xdg.enable = true;
    xdg.cacheHome = "${config.home.homeDirectory}/.cache";
    xdg.configHome = "${config.home.homeDirectory}/.config";
    xdg.dataHome = "${config.home.homeDirectory}/.local/share";
    xdg.stateHome = "${config.home.homeDirectory}/.local/state";
  
    programs.fish = {
      enable = true;
      interactiveShellInit = "fish_vi_key_bindings";
      shellAliases.ls = "exa --group-directories-first";
    };
  
    programs.git = {
      enable = true;
      userName = config.personal.fullName;
      userEmail = config.personal.email;
      signing.key = "1BA5F1335AB45105";
      signing.signByDefault = true;
      # "Are the worker threads going to unionize?"
      extraConfig.init.defaultBranch = "main";
    };
  
    programs.gh = {
      enable = true;
      settings.git_protocol = "ssh";
    };
  
    programs.ssh.enable = true;
  
    programs.gpg = {
      enable = true;
      homedir = "${config.xdg.dataHome}/gnupg";
    };
  
    xdg.configFile.gopass = {
      target = "gopass/config";
      text = ''
        [mounts]
            path = ${config.defaultDirectories.repositoriesDirectory}/passwords
        [recipients]
            hash = c9903be2bdd11ffec04509345292bfa567e6b28e7e6aa866933254c5d1344326
      '';
    };
  };
#+end_src

** Darwin home

I got the nice ~pman~ command from this [[https://robservatory.com/open-postscript-files-in-preview-in-macos-ventura/][blog post]], which shows how to
open man pages in Preview.

#+begin_src nix
darwinHome = { config, pkgs, nixcasks, lib, ... }:

{
  imports = [ home emacsConfiguration defaultSettings ];
   
  nixpkgs.overlays = [ (final: prev: { inherit nixcasks; }) ];

  home.homeDirectory = "/Users/${config.personal.userName}";
  home.packages = with pkgs; [
    jetbrains-mono
    (pkgs.texlive.combine {
      inherit (pkgs.texlive) scheme-basic
        dvisvgm dvipng
        wrapfig amsmath ulem hyperref capt-of
        bussproofs;
    })
  ];

  programs.fish = {
    interactiveShellInit = "eval (brew shellenv)";
    functions.pman = "mandoc -T pdf (man -w $argv) | open -fa Preview";
  };

  programs.emacs.package = emacsOverlay pkgs pkgs.emacsMacport;
  home.sessionVariables.EDITOR = "emacsclient";
};
#+END_SRC

*** ~default~ settings
#+BEGIN_SRC nix
defaultSettings = { config, lib, ... }:

{
  home.activation = {
    activateSettings = lib.hm.dag.entryAfter
      [ "writeBoundary" ] 
      "/System/Library/PrivateFrameworks/SystemAdministration.framework/Resources/activateSettings -u";
  };

  targets.darwin.defaults = {
    NSGlobalDomain = {
      AppleInterfaceStyleSwitchesAutomatically = true;
      WebKitDeveloperExtras = true;
    };

    "com.apple.dock" = {
      orientation = "left";
      autohide = true;
    };

    "com.apple.screencapture" = {
      location = config.defaultDirectories.scratchDirectory;
    };

    "com.apple.Safari" = {
      AutoOpenSafeDownloads = false;
      SuppressSearchSuggestions = true;
      UniversalSearchEnabled = false;
      AutoFillFromAddressBook = false;
      AutoFillPasswords = false;
      IncludeDevelopMenu = true;
      SandboxBroker.ShowDevelopMenu = true;
      AutoFillCreditCardData = false;
      AutoFillMiscellaneousForms = false;
      ShowFavoritesBar = false;
      WarnAboutFraudulentWebsites = true;
      WebKitJavaEnabled = false;
    };

    "com.apple.AdLib" = {
      allowApplePersonalizedAdvertising = false;
    };

    "com.apple.finder" = {
      AppleShowAllFiles = true;
      ShowPathbar = true;
    };

    "com.apple.print.PrintingPrefs" = {
      "Quit When Finished" = true;
    };

    "com.apple.SoftwareUpdate" = {
      AutomaticCheckEnabled = true;
      ScheduleFrequency = 1;
      AutomaticDownload = 1;
      CriticalUpdateInstall = 1;
    };
  };
};
#+end_src
* Emacs
** Nix
:PROPERTIES:
:header-args: :noweb-ref modules
:END:

*** Overlay
This is not actually a NixOS module. I guess it doesn't matter for
now.

I guess the lean4-mode package is not on MELPA, so I had to figure out
how to add a custom emacs package using ~fetchFromGitHub~. Long story
short: always check the Nix wiki entry before anything else. It'll
usually shoot you straight. Here's what I used:

- [[https://nixos.wiki/wiki/Emacs#Adding_packages_from_outside_ELPA_.2F_MELPA]]
- [[https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/lean4-mode.20with.20nix-doom-emacs/near/291790287]]
- https://github.com/NixOS/nixpkgs/issues/191128

#+begin_src nix
emacsOverlay = (pkgs: package:
  (pkgs.emacsWithPackagesFromUsePackage {
    inherit package;
    config = ./emacs.el;
    defaultInitFile = true;
    extraEmacsPackages = epkgs: with epkgs; [
      treesit-grammars.with-all-grammars
    ];
    override = epkgs: epkgs // {
      lean4-mode = epkgs.trivialBuild rec {
        pname = "lean4-mode";
        version = "1";
        src = pkgs.fetchFromGitHub {
          owner = "bustercopley";
          repo = "lean4-mode";
          rev = "f6166f65ac3a50ba32282ccf2c883d61b5843a2b";
          sha256 = "sha256-mVZh+rP9IWLs2QiPysIuQ3uNAQsuJ63xgUY5akaJjXc=";
        };
        propagatedUserEnvPkgs = with epkgs;
          [ dash f flycheck lsp-mode magit-section s ];
        buildInputs = propagatedUserEnvPkgs;
        postInstall = ''
          DATADIR=$out/share/emacs/site-lisp/data
          mkdir $DATADIR
          install ./data/abbreviations.json $DATADIR
        '';
      };
    };
    alwaysEnsure = true;
  }));
#+end_src

*** Module

#+begin_src nix
emacsConfiguration = { pkgs, ... }:

  {
    nixpkgs.overlays = with emacs-overlay.overlays; [ emacs package ];

    programs.emacs.enable = true;
  };
#+end_src

** Configuration
:PROPERTIES:
:header-args: :tangle emacs.el
:END:

*** Disable package manager
I'm not actually sure where I got this code, and I'm not sure it's
even working. When I've searched it, most people are using it in their
~early-init.el~, which I'm not sure how to get working with
~emacsWithPackagesFromUsePackage~.

#+begin_src elisp
(setq package-enable-at-startup nil)
(setq use-package-ensure-function 'ignore)
(setq package-archives nil)

(setq use-package-always-ensure t)
(eval-when-compile (require 'use-package))
;; Required for ~:bind~ to work later
(require 'bind-key)
#+end_src

*** Defaults
I gotta work on this. Much of this is pulled from Emacs configuration
I started back in 2019-2020. A lot of it is probably not necessary but
I'm a little scared to touch it for fear I'll rediscover one of the
painful experiences that led me to try "fixing it" here.

#+begin_src elisp
(when (fboundp 'menu-bar-mode) (menu-bar-mode 0))
(when (fboundp 'tool-bar-mode) (tool-bar-mode 0))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode 0))
(when (eq system-type 'gnu/linux)
  (add-to-list 'default-frame-alist '(undecorated . t))
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))
(add-to-list 'default-frame-alist `(font . ,(if (eq system-type 'gnu/linux) "JetBrainsMono 12" "JetBrains Mono 14")))
(setq visible-bell t)
(setq display-line-numbers-type 'visual)
(global-display-line-numbers-mode)

(setq local-directory (expand-file-name "~/.local/data/emacs/"))
(setq backup-directory (concat local-directory "backups/"))
(setq auto-save-directory (concat local-directory "auto-saves/"))
(setq backup-directory-alist '(("*" . ,backup-directory)))
(setq backup-inhibited t)
(setq auto-save-file-name-transforms `((".*" ,auto-save-directory t)))
(setq auto-save-list-file-prefix auto-save-directory)
(setq auto-save-default nil)
(setq create-lockfiles nil)
(setq vc-make-backup-files t)
(setq custom-file (concat user-emacs-directory "custom.el"))

(setq-default indent-tabs-mode nil)
#+end_src

Here's how I think I'm going to do this. Below this paragraph is all
of the emacs defaults that I've added since making the configuration
literate. I'll just incrementally add stuff here as it becomes
relevant to me.

Some use-package guidance: see [[https://github.com/jwiegley/use-package#getting-started][the README]] for more details.

Does ~config~ load before or after the package loads? The ~init~
keyword is for code that should run before, the ~config~ keyword is
for code that should run after.

*** Evil mode
#+begin_src elisp
(use-package evil
 :init
 (setq evil-want-keybinding nil)
 :custom
 (evil-undo-system 'undo-redo)
 :config
 (evil-mode 1))

(use-package evil-collection
 :after evil
 :custom (evil-want-keybinding nil)
 :init
 (evil-collection-init))
#+end_src

*** Dired
- https://www.youtube.com/watch?v=L_4pLN0gXGI
- Dired hide details mode
- M-<p,n>! Searches back and forward in mini buffer search history!

*** Org
Still very much in the learning stage with org-mode.

Useful stuff:

- [[http://doc.norang.ca/org-mode.html]]

#+begin_src elisp
(setq org-src-preserve-indentation nil
      org-edit-src-content-indentation 0
      org-confirm-babel-evaluate nil
      org-babel-load-languages
        '((emacs-lisp . t)
          (shell . t)
          (python . t))
      org-latex-compiler "lualatex"
      org-latex-create-formula-image-program 'dvisvgm
      org-preview-latex-image-directory temporary-file-directory
      org-latex-packages-alist '(("" "bussproofs" t))
      org-startup-with-latex-preview t
      org-startup-with-inline-images t
      org-agenda-span 14)
(with-eval-after-load 'org
  (plist-put org-format-latex-options :background "Transparent"))
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(use-package org-ql)
(use-package org-roam-ql)

(use-package org-fragtog
  :hook (org-mode . org-fragtog-mode))

(use-package org-roam
  :custom
  (org-roam-v2-ack t)
  (org-directory "~/share")
  (org-roam-directory "~/share/notes")
  (org-roam-dailies-directory "journals/")
  (org-cite-global-bibliography '("~/share/notes/citations.bib"))
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?" :target
      (file+head "pages/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert))
  :config
  (require 'oc-basic)
  (org-roam-setup))

(use-package org-roam-ui
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))

(use-package org-gtd
  :after
  org
  :init
  (setq org-gtd-update-ack "3.0.0")
  :custom
  (org-gtd-directory "~/share/org/gtd/")
  (org-edna-use-inheritance t)
  :config
  (org-edna-mode)
  (org-gtd-mode)
  :bind
  (("C-c d c" . org-gtd-capture)
   ("C-c d d" . (lambda (&optional GOTO)
                  (interactive)
                  (org-gtd-capture GOTO "i")))
   ("C-c d p" . org-gtd-process-inbox)
   :map org-gtd-clarify-map
   ("C-c c" . org-gtd-organize)))
#+end_src

*** Completion
Dude I just copied these hip packages from wherever I first saw them
on the internet, I don't actually understand them. They look very pretty though.

#+begin_src elisp
(use-package vertico
  :init
  (vertico-mode)
  :hook ((rfn-eshadow-update-overlay . #'vertico-directory-tidy)))

(use-package marginalia
  :init
  (marginalia-mode))

(use-package consult
  :bind (("C-x b" . consult-buffer)
         ("C-x p b" . consult-project-buffer)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("M-s d" . consult-find)
         ("M-s g" . consult-ripgrep)))

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

I suppose ~which-key~ also counts as a completion menu thing. Honestly it
should built into emacs, I would be so screwed without it.

#+begin_src elisp
(use-package which-key
  :config (which-key-mode 1))
#+end_src

There's also ~company~ and ~yasnippet~, which I've never really gone
without so I honestly couldn't say where normal emacs completion
ends and these two start.

#+begin_src elisp
(use-package company
  :custom
  (company-idle-delay 0.1)
  :bind
  (:map company-active-map
	("C-n" . company-select-next)
	("C-p" . company-select-previous))
  :init
  (global-company-mode))
#+end_src

#+begin_src elisp
(use-package yasnippet
  :config
  (yas-reload-all)
  (add-hook 'prog-mode-hook 'yas-minor-mode)
  (add-hook 'text-mode-hook 'yas-minor-mode))
#+end_src
*** Debugging
#+begin_src elisp
(use-package dap-mode
  :after lsp-mode
  :commands dap-debug
  :hook ((python-mode . dap-ui-mode)
	 (python-mode . dap-mode))
  :custom
  (dap-python-debugger 'debugpy)
  :config
  (eval-when-compile
    (require 'cl))
  (require 'dap-python)
  (require 'dap-lldb))
#+end_src

*** Themes
Emacs themes: just skip to the end, discover [[https://protesilaos.com][Protesilaos Stavrou]], and
install the ~ef~ themes. Apparently he's building a hut in the Cyprus
mountains?

#+begin_src elisp
(use-package standard-themes)

(use-package modus-themes)

(use-package ef-themes 
  :init
  (load-theme 'ef-light t))
#+end_src

*** Racket
#+begin_src elisp
(use-package racket-mode)
#+end_src
*** Rust
#+begin_src elisp
(use-package rust-mode
  :hook
  ((rust-mode . eglot-ensure)
   (rust-mode . flycheck-mode))
  :config
  (setq-default eglot-workspace-configuration
                '(:rust-analyzer (:check (:command "clippy")))))
#+end_src

*** Proof general
[[https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/][The holy trinity.]]

#+begin_src elisp
(use-package proof-general)
#+end_src

*** Lean
#+begin_src elisp
(use-package lean4-mode
  :mode "\\.lean\\'")
#+end_src

*** Haskell
#+begin_src elisp
(use-package haskell-mode
  :hook
  ((haskell-mode . eglot-ensure)))
#+end_src

*** Magit
#+begin_src elisp
(use-package magit)
#+end_src

*** Nix
"Yep! Make a symlink! You’re an adult!"

#+begin_src elisp
(use-package nix-mode
  :mode "\\.nix\\'")

(use-package envrc
  :config
  (envrc-global-mode))
#+end_src

* Secrets

At this point in my life, I've decided that I don't understand ssh
keys. I've come off Mount Stupid and am in the Valley of Despair. From
this [[https://superuser.com/questions/189355/is-it-ok-to-share-private-key-file-between-multiple-computers-services][stack exchange post]] and other things I've read, my best guess is
that I am *NOT* supposed to have some user key who's private key is
on multiple computers. That would be bad. I should instead have one
key per machine, and there should only be one copy anywhere.

#+begin_src nix :tangle secrets/secrets.nix
let
  kenobi = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBndIK51b/o6aSjuTdoa8emnpCRg0s5y68oXAFR66D4/ jacksontbrough@gmail.com";
  share1 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFpnGMEUElcwgnuHpBXQa4xotZrRdT6VC/7b9n5TykXZ root@share1";
in
{
  "share1-auth-key1.age".publicKeys = [ kenobi share1 ];
  "webdav-user1.age".publicKeys = [ kenobi share1 ];
  "wireless.age".publicKeys = [ kenobi share1 ];
}
#+end_src

* Templates
:PROPERTIES:
:header-args: :noweb-ref templates
:END:

** Rust
#+begin_src nix
templates.rust = {
  path = ./templates/rust;
  description = "Rust template";
};
#+end_src

** Python
#+begin_src nix
templates.python = {
  path = ./templates/python;
  description = "Python template";
};
#+end_src

** Herbie
[[https://github.com/herbie-fp/herbie]]

#+begin_src nix
templates.herbie = {
  path = ./templates/herbie;
  description = "Herbie template";
};
#+end_src

** Coq
After ~nix flake init~-ing, you'll want to create a ~_CoqProject~
file, containing the line

#+begin_src text :noweb-ref no
-Q . <namespace>
#+end_src

where ~<namespace>~ is the name of whatever is going on with modules
and packages in Coq. Then you'll want to run

#+begin_src shell :noweb-ref no
coq_makefile -f _CoqProject *.v -o Makefile
#+end_src

Then you can ~make~ and ~make clean~. I got this from reading Software
Foundations, specifically from the beginning of the [[https://softwarefoundations.cis.upenn.edu/lf-current/Induction.html][chapter on induction]].

#+begin_src nix
templates.coq = {
  path = ./templates/coq;
  description = "Coq template";
};
#+end_src
* Systems
:PROPERTIES:
:header-args: :noweb-ref systems
:END:

** ~kenobi~

#+begin_src nix
darwinConfigurations.kenobi = nix-darwin.lib.darwinSystem {
  modules = with nixosModules; [
    darwinSystem
    {
      nixpkgs.hostPlatform = "x86_64-darwin";
    }
  ];
};
homeConfigurations."jackson@kenobi" = home-manager.lib.homeManagerConfiguration {
  pkgs = import nixpkgs {
    system = "x86_64-darwin";
    config.allowUnfree = true;
  };
  modules = with nixosModules; [ darwinHome ];
  extraSpecialArgs.nixcasks = nixcasks.legacyPackages."x86_64-darwin";
};
#+end_src

* Commands
** Running ~home-manager switch~ without Home Manager 
#+begin_src sh
nix run github:broughjt/dotfiles#homeConfigurations.jackson@<machine>.activationPackage
#+end_src
** Raspberry Pi Serial Console
See
[[https://www.jeffgeerling.com/blog/2021/attaching-raspberry-pis-serial-console-uart-debugging]].

#+begin_src shell
screen /dev/tty.usbserial-1420 115200
#+end_src
** Installing nix-darwin from scratch
See [[https://github.com/LnL7/nix-darwin#flakes]].

Step 1 is creating the flake (enabling the proper flags for stupid
reasons nix is experimental):

#+begin_src shell
nix flake --extra-experimental-features nix-command --extra-experimental-features flakes init -t nix-darwin
#+end_src

Then run this command to install nix-darwin:

#+begin_src shell
nix run --extra-experimental-features nix-command --extra-experimental-features flakes nix-darwin -- switch --flake /path/to/flake.nix
#+end_src

** Adding new ssh keys to GitHub

If you need to generated a new one, see
https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent.

Then run

#+begin_src shell
pbcopy < ~/.ssh/id_ed25519.pub
#+end_src

but substitute ~id_ed25519~ for the actual name of your public key file.

To test connection,

#+begin_src shell
ssh -T git@github.com
#+end_src
* COMMENT Local variables
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
* Footnotes
[fn:1] "No. Suffer my pain"
[fn:2] https://twitter.com/bcantrill/status/1007680560133623808 
